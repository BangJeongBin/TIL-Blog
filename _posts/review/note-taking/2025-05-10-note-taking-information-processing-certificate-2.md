---
title: 정보처리기사 Note-Taking (2)
description: 정보처리기사 요약 노트 정리 2편
author: bin
date: 2025-05-10 09:00:00 +0800
categories: [Review, Note-Taking]
tags: [Network, CS]
pin: true
math: true
mermaid: true
image:
 path: https://bangjeongbin.github.io/TIL-Blog/assets/img/posts/common/note-taking-logo.png
 alt: Note Taking
---

> 해당 포스트는 학습 목적으로 작성되었으며 <<[2025 시나공 정보처리기사 실기 기본서](https://product.kyobobook.co.kr/detail/S000215623877)>>을 참고하여 작성하였음을 알려드립니다.

<br>

# 2장 - 데이터 입 / 출력 구현
---

## 029 데이터베이스 개요
---
### DBMS(DataBase Management System; 데이터베이스 관리 시스템)

|                     | DBMS 필수기능 3가지                                   |
| :-----------------: | ----------------------------------------------- |
|  정의(Definition) 기능  | 데이터의 형(Type)과 구조에 대한 정의, 이용방식, 제약 조건 등을 명시하는 기능 |
| 조작(Manipulation) 기능 | 데이터의 검색, 갱신, 삽입, 삭제 등을 위해 인터페이스 수단을 제공하는 기능     |
|   제어(Control) 기능    | 데이터의 무결성, 보안, 권한 검사, 병행 제어를 제공하는 기능             |

---
### 스키마(Schema)

- 스키마는 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것

|   종류   | 내용                                                                                         |
| :----: | ------------------------------------------------------------------------------------------ |
| 외부 스키마 | - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적인 구조를 정의한 것                                  |
| 개념 스키마 | - 데이터베이스의 전체적인 논리구조<br>- <u>하나만 존재</u>                                                     |
| 내부 스키마 | - <u>물리적 저장장치</u>의 입장에서 본 데이터베이스 구조<br>- 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 |

---

<br>

## 030 데이터베이스 설계
----
### 데이터베이스 설계 순서

- <span style="color:red">중요</span>
1. `요구 조건 분석`
	- 요구조건 명세서 작성
2. `개념적 설계`
	- 개념 스키마, 트랜잭션 모델링, E-R 모델
3. `논리적 설계`
	- 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
4. `물리적 설계`
	- 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
5. `구현`
	- 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성
---

<br>

## 034 관계형 데이터베이스의 구조 / 관계형 데이터 모델
---
### 튜플(Tuple)

- 릴레이션을 구성하는 각각의 행을 말함
- 속성의 모임으로 구성되고 파일 구조에서 레코드와 같은 의미임
- <u>튜플의 수를 카디널리티(Cardinality)라고 함</u>

---
### 속성(Attribute)

- 데이터베이스를 구성하는 가장 작은 논리적 단위
- <u>속성의 수를 디그리(Degree) 또는 차수 라고 함</u>

---
### 도메인(Domain)

- 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합

>e.g. '성별' 애트리뷰트의 도메인은 "남"과 "여"로, 그 외의 값은 입력될 수 없다.

---
### 릴레이션의 특징

- 한 릴레이션에 포함된 튜풀 사이에는 순서가 없다.
- 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다.
- 릴레이션 스키마를 구성하는 속성 간의 순서는 중요하지 않다.

---

<br>

## 035 관계형 데이터베이스의 제약조건 - 키(Key)
---
### 키

- 키의 종류
	- 후보키(Candidate Key)
	- 기본키(Primary Key)
	- 대체키(Alternate Key)
	- 슈퍼키(Super Key)
	- 외래키(Foreign Key)

---
### 후보키(Candidate Key)

- 속성들 중애서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합
- <u>유일성(Unique)와 최소성(Minimality)을 모두 만족</u>

> 유일성(Unique) : 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함

> 최소성(Minimality) : 키를 구성하는 속성 하나를 제거하면 유일하게 실별할 수 없도록 꼭 필요한 최소의 속성올 구성되어야 함

---
### 기본키(Primary Key)

- 후보키 중에서 특별히 선정된 주키(Main Key)
- 기본키는 중복된 값과 Null값을 가질 수 없다.

---
### 대체키(Alternate Key)

- 후보키가 둘 이상일 때 기본기를 제외한 나머지 후보키
- 보조키라고도 함

---
### 슈퍼키(Super Key)

- 속성들의 집합으로 구성된 키
- <u>유일성(Unique)은 만족하지만 최소성(Minimality)은 만족하지 못함</u>

---
### 외래키(Foreign Key)

- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들이 집합

---

<br>

## 036 관계형 데이터베이스의 제약조건 - 무결성(Integrity)
---
### 무결성(Integrity)

- 데이터베이스에 저장된 데이터의 값과 현실 셰계의 실제 값이 일치하는 정확성을 의미

---
### 무결성의 종류

|    종류    | 내용                                                                              |
| :------: | ------------------------------------------------------------------------------- |
|  개체 무결성  | 기본 테이블의 기본키를 규정하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정                              |
|  참조 무결성  | 외래키 값은 **Null이거나** 참조 릴레이션의 기본키 값과 동일해야 함. 즉 릴레이션은 참조할 수 없는 외래키의 값을 가질 수 없다는 규정 |
| 도메인 무결성  | 주어진 속성의 값이 정의된 도메인에 속한 값이어야 한다는 규정                                              |
| NULL 무결성 | 릴레이션의 특정 속성 값이 Null이 될 수 없도록 하는 규정                                              |
|  고유 무결성  | 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다는 규정                                    |
|  키 무결성   | 하나의 릴레션에는 적어도 하나의 키다 존재해야 한다는 규정                                                |
|  관계 무결성  | 릴레이션의 어느 한 튜블의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정       |

---

<br>

## 037 관계대수 및 관계해석
---
### 관계대수

- 원하는 정보와 그 정보를 검색하기 위해 어떻게 유도하는가를 기술하는 <u>절차적인 언어</u>

---
### 순수 관계 연산자

|    종류    | 특징                                                                               |   기호   |
| :------: | -------------------------------------------------------------------------------- | :----: |
|  Select  | - 릴레이션의 행에 해당하는 튜플(Tuple)을 구하는 것. 수평연산이라고 함                                      | σ(시그마) |
| Project  | - 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산. 수직연산이라고 함 | 𝜋(파이) |
|   Join   | - <u>Join의 결과는 Cartesian Product(교차곱)를 수행한 다음 Select를 수행한 것과 값음</u>              |   ⨝    |
| Division | - 두 개의 릴레이션 R과 S가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산      |   ÷    |

---
### 일반 집합 연산자

- 수학적 집합 이론에서 사용하는 연산자

|           연산자            | 기능 및 수학적 표현                        | 기호  |
| :----------------------: | ---------------------------------- | :-: |
|       합집합<br>UNION       | - <u>합집합을 구하되 중복되는 튜플은 제거되는 연산</u> |  ⋃  |
|   교집합<br>INTERSECTION    | - <u>교집합을 구하는 연산</u>               |  ⋂  |
|    차집합<br>DIFFERENCE     | - <u>차집합을 구하는 연산</u>               |  −  |
| 교차곱<br>CARTESIAN PRODECT | - 순서쌍을 구하는 연산                      |  ×  |

---
### 관계해석

- 관계 데이터의 연산을 표현하는 방법
- <u>관계대수와 반대로 비절차적 언어</u>

---

<br>

## 038 이상 / 함수적 종속
---
### 이상(Anomaly)

- 데이터의 중복이 발생하고, 이 중복(Redundancy)으로 문제가 발생하는 현상
- 이상의 종류
	- 삽입 이상(Insertion Anomaly)
	- 삭제 이상(Deletion Anomaly)
	- 갱신 이상(Update Anomaly)

1. 삽입 이상(Insertion Anomaly) : 테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상

2. 삭제 이상(Deletion Anomaly) : 테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상

3. 갱신 이상(Update Anomaly) : 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성(Inconsistency)이 생기는 현상

---
### 함수적 종속(Funtional Dependency)

- 예시

`<학생>` 테이블

| 학번  | 이름  | 학년  |   학과   |
| :-: | :-: | :-: | :----: |
| 400 | 이순신 |  4  | 컴퓨터공학과 |
| 422 | 유관순 |  4  |  물리학과  |
| 301 | 강감찬 |  3  |  수학과   |
| 320 | 홍길동 |  3  |  체육과   |

`<학생>` 테이블에서 이름, 학년, 학과는 각각 학번 속성에 함수적 종속이다. 이것을 기호로 표시하면 다음과 같다.
 
표시 예1

```
학번 -> 이름
학번 -> 학년
학번 -> 학과
```
 
표시 예2

```
학번 -> 이름, 학년, 학과
```


> X -> Y 의 관계를 갖는 속성에서 X를 **결정자(Determinant)** 라 하고, Y를 **종속자(Dependent)** 라고 한다.
> 예를 들어 `학변 -> 이름`에서는 학번이 **결정자** 이고 학생이 **종속자** 이다.

---

<br>

## 039 정규화(Normalization)
---
### 정규화(Normalization)

- 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정
- 정규화의 목적은 가능한 한 <u>중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것</u> 이다.

---
### 정규화 과정

1. `비정규 릴레이션`
	- <span style="color:red">도</span>메인이 원자값
2. `1NF`
	- <span style="color:red">부</span>분적 함수 종속 제거
3. `2NF`
	- <span style="color:red">이</span>행적 함수 종속 제거
4. `3NF`
	- <span style="color:red">결</span>정자이면서 후보키가 아닌 것 제거
5. `BCNF`
	- <span style="color:red">다</span>치 종속 제거
6. `4NF`
	- <span style="color:red">조</span>인 종속성 이용
7. `5NF`

- <span style="color:red">도부이결다조</span> - 암기

---

<br>

## 반정규화(Denormalization)
---
### 반정규화(=비정규화)

- 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위이다.
- 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다. 과도한 반정규화는 오히려 성능을 저하시킬 수 있다.

- 반정규화 방법
	- 테이블 통합
	- 테이블 분할
	- 중복 테이블 추가
	- 중복 속성 추가

---

<br>

## 042 트랜잭션 분석 / CRUD 분석
---
### 트랜잭션(Transaction)

- 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산

---
### 트랜잭션의 특성

- <span style="color:red">중요</span>

|            특성            | 의미                                                                         |
| :----------------------: | -------------------------------------------------------------------------- |
|      Atomicity(원자성)      | 트랙잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 함 |
|     Consistency(일관성)     | 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함                           |
| Isolation(독립성, 격리성, 순차성) | 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음          |
|   Durability(영속성, 지속성)   | 성공적을 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함                               |

---

<br>

## 044 뷰 / 클러스터
---
### 뷰(View)

- 하나 이상의 기본 테이블로부터 유도된 가상 테이블

---
### 뷰(View)의 장 / 단점

| 장점                                                                           | 단점                                                                                 |
| ---------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| - 논리적 데이터 독립성을 제공<br>- 동일 데이터에 대해 여러 사용자에 상이한 요구 지원<br>- 접근 제어를 통한 자동 보안이 제공 | - 독립적인 인덱스를 가질 수 없음<br>- 뷰의 정의를 변경 할 수 없음<br>- 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름 |

---

<br>

## 046 분산 데이터베이스 설계
---
### 분산 데이터베이스 설계

- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 사이트(Site)에 분산된 데이터베이스를 뜻함

---
### 분산 데이터베이스의 목표

1. 위치 투명성(Location Transparency)
	- 엑세스하려는 데이터베이스의 실제 위치를 알 필요가 없이 단지 논리적인 명칭만으로 엑세스 할 수 있다.

2. 중복 투명성(Replication Transparency)
	- 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것 처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행한다.

3. 병행 투명성(Concurrency Transparency)
	- 분산 데이터베이스와 관련된 다수의 트랜잭션 들이 동시에 실현되더라도 그 트랜잭션의 결과를 영행을 받지 않는다.

4. 장애 투명성(Failure Transparency)
	- 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다.

---

<br>

## 048 데이터베이스 보안
---
### 암호화(Encryption)

- 암호화 기법
	- 개인키 암호 방식(Private Key Encryption)
	- 공개키 암호 방식(Public Key Encryption)

---
### 접근통제

- <span style="color:red">중요</span>

|        정책        | 특징                                                                                       |
| :--------------: | ---------------------------------------------------------------------------------------- |
|  임의 접근 통제(DAC)   | - **사용자의 신원에 따라** 접근 권한을 부여하는 방식<br>- 데이터 소유자가 접근통제 권한을 지정하고 제어함                         |
|  강제 접근 통제(MAC)   | - **주체와 객체의 등급의 비교하여** 접근 권한을 부여하는 방식<br>- 시스템이 접근통제 권한을 지정함<br>- 사용자 별로 인가 등급을 부여할 수 있음 |
| 역할기반 접근 통제(RBAC) | - **사용자의 역할에 따라** 접근 권한을 부여하는 방식<br>- 중앙관리자가 접근통제 권한을 지정함<br>- 다중 프로그래밍 환경에 최적화된 방식      |

---

<br>

## 049 데이터베이스 백업
---
### 로그 파일

- 로그파일은 데이터배이스의 상태변화를 시간의 흐름에 따라 모두 기록한 파일이다.

- UNDO(복귀) : 로그(Log)에 보관한 정보를 이용하여 가장 최근에 변경 된 내용부터 거슬로 올라가면서 트랜잭션 작업을 취소하여 원래의 데이터베이스로 복구함
- REDO(재생) : 덤프(Dump)와 로그(Log)를 이용하여 가장 최근의 정상적인 데이터베이스로 회복시킨 후 트랜잭션을 재실행 시킴

---

<br>

## 050 스토리지
---
### 스토리지(Storage)

- 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술이다.
- 스토리지의 종류는 DAS, NAS, SAN이 있다.

---
### DAS(Direct Attached Storage)

- 서버와 저장장치를 전용케이블로 직접 연결하는 방식
- 특징 : 초기 구축 비용 및 유지보수 비용이 저렴하다. 그 대신 확장성 및 유연성이 떨어진다.

---
### NAS(Network Attached Storage)

- 서버와 저장장치를 네트워크를 통해 연결하는 방식
- 특징 : 장소에 구애받지 않고 저장장치에 접근 가능. DAS에 비해 확장성 및 유연성이 우수하다.

---
### SAN(Storage Area Network)

- 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식이다.
- 특징 : 광케이블을 이용해 처리속도가 빠르다. 저장장치를 공유함으로써 여러개의 장비를 단일화시킬 수 있다. 확장성, 유연성, 가용성이 뛰어나다.

---

<br>

## 052 자료구조
---
### 자료구조

- 선형 구조(Linear Structure)
	- 배열(Array)
	- 선형 리스트(Linear List)
		- 연속 리스트(Contiguous List)
		- 연결 리스트(Linked List)
	- 스택(Stack)
	- 큐(Queue)
	-  데크(Deque)

- 비선형 구조(Non-Linear Structure)
	- 트리(Tree)
	- 그래프(Graph)

---
### 배열(Array)

- 크기와 형(Type)이 동일한 자료들이 순서대로 나열된 자료의 집합
- 정적인 자료 구조로 기억장소의 추가가 어렵고, 데이터 삭제 시 기억장소가 빈 공간으로 남아있어 메모리의 낭비가 발생한다.

---
### 연속 리스트(Contiguous List)

- 연속되는 기억장소에 저징되는 자료 구조
- 삽입 / 삭제 시 자료의 이동이 필요하다.

---
### 연결 리스트(Linked List)

- 자료들을 임의의 기억공간에 기억시키되, 노드[^1] 의 포인터 부분을 이용하여 서로 연결시킨 자료 구조
- 접근 속도가 느리고, 연결이 끊어지면 다음 노드를 찾기 어렵다

[^1]: 노드는 자료를 저장하는 데이터 부분과 다음 노드를 가리키는 포인터인 링크 부분으로 구성된 기억공간임

---
### 스택(Stack)

- 리스트의 한쪽 끝으로만 자료의 삽입, 삭제, 작업이 이루어지는 자료 구조
- **후입선출(LIFO; Last In First Out)** 방식으로 자료를 처리
- 저장 할 공간이 없는 상태에서 삽입시 오버플로(Overflow)가 삭제할 데이터가 없는 상태에서 데이터를 삭제 시 언더플로(Underflow)가 발생한다.

---
### 큐(Queue)

- 리스트의 한쪽에서는 삽입 작업이, 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조
- **선입선출(FIFO; First In First Out)** 방식으로 자료를 처리
- 시작을 표시하는 프론트(Front) 포인터와 끝을 표시하는 리어(Rear) 포인터가 있다.

---
### 그래프(Graph)

- 정점(Vertex)과 간선(Edge)의 두 집합으로 이루어지는 자료 구조
- 사이클이 없는 그래프(Graph)를 트리(Tree)라고 한다.

---

<br>

## 054 이진트리
---
### 이진 트리

- 차수(Degree)가 2 이하인 노드들로 구성된 트리

---
### 트리의 운행법

- Preorder(전위) 운행
- Inorder(중위) 운행
- Postorder(후위) 운행

![binary-tree-order](https://lh3.googleusercontent.com/d/19mekSUiyUFeLaIWuvviTwbJ6yoU9rVsV)
이진 트리 운행법[^1]

---

<br>

## 055 정렬(Sort)
---
### 삽입 정렬(Insertion Sort)

- 평균 수행 시간 복잡도 : $O(n^2)$
- 최악 수행 시간 복잡도 : 〃

![Insertion Sort](https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif)
Insertion Sort[^2]

---
### 선택 정렬(Selection Sort)

- 평균 수행 시간 복잡도 : $O(n^2)$
- 최악 수행 시간 복잡도 : 〃

![Selection sort](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)
Selection Sort[^3]

---
### 버블정렬(Bubble Sort)

- 평균 수행 시간 복잡도 : $O(n^2)$
- 최악 수행 시간 복잡도 : 〃

![Bubble Sort](https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif?20110309111239)
Bubble Sort[^4]

---
### 쉘 정렬(Shell Sort)

- 평균 수행 시간 복잡도 : $O(n^{1.5})$
- 최악 수행 시간 복잡도 : $O(n^2)$

---
### 퀵 정렬(Quick Sort)

- 평균 수행 시간 복잡도 : $O(n\log_2n)$
- 최악 수행 시간 복잡도 : $O(n^2)$

---
### 힙 정렬(Heap Sort)

- 평균 수행 시간 복잡도 : $O(n\log_2n)$
- 최악 수행 시간 복잡도 : 〃

---
### 2-Way 합병 정렬(Merge Sort)

- 평균 수행 시간 복잡도 : $O(n\log_2n)$
- 최악 수행 시간 복잡도 : 〃

---
### 기수 정렬(Radix Sort) == Bucket Sort

- 평균 수행 시간 복잡도 : $O(dn)$
- 최악 수행 시간 복잡도 : 〃

---

<br>

## References
---
[^1]: 출처 : https://y-oni.tistory.com/68
[^2]: 출처 : https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif
[^3]: 출처 : https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC
[^4]: 츨처 : https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif
